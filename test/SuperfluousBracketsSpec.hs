{-# LANGUAGE RecordWildCards, NamedFieldPuns, TypeApplications #-}

module SuperfluousBracketsSpec (spec) where

import Test.QuickCheck (Gen, forAll, choose, suchThat, (==>))
import Data.Either.Extra (fromRight')
import Data.List.Extra (notNull)
import Test.Hspec (Spec, describe, it)
import Text.Parsec (parse)

import Tasks.SuperfluousBrackets.Quiz (generateSuperfluousBracketsInst)
import Tasks.SuperfluousBrackets.Config(
  SuperfluousBracketsConfig(..),
  SuperfluousBracketsInst(..),
  checkSuperfluousBracketsConfig,
  defaultSuperfluousBracketsConfig)
import Tasks.SynTree.Config (SynTreeConfig(..))
import SynTreeSpec (validBoundsSynTreeConfig)
import Trees.Types (SynTree(..), BinOp(..), PropFormula)
import Trees.Helpers (numberAllBinaryNodes, sameAssociativeOperatorAdjacent, treeNodes)
import Trees.Print (display, simplestDisplay)
import Tasks.SuperfluousBrackets.PrintSuperfluousBrackets (
  superfluousBracketsDisplay,
  sameAssociativeOperatorAdjacentSerial
  )
import Trees.Parsing(formulaParse)
import TestHelpers (deleteBrackets, doesNotRefuse)
import Trees.Generate (genSynTree)
import Formula.Parsing (Parse(parser))
import Control.OutputCapable.Blocks (LangM)
import LogicTasks.Syntax.SimplestFormula (description, partialGrade', completeGrade')

validBoundsSuperfluousBracketsConfig :: Gen SuperfluousBracketsConfig
validBoundsSuperfluousBracketsConfig = do
    syntaxTreeConfig@SynTreeConfig {..} <- validBoundsSynTreeConfig `suchThat` \SynTreeConfig{..} -> 2 * minUniqueBinOperators + 2 < minNodes
    superfluousBracketPairs <- choose (1, minNodes `div` 2)
    return $ SuperfluousBracketsConfig
        {
          syntaxTreeConfig
        , superfluousBracketPairs
        , extraText = Nothing
        , printSolution = False
        , offerUnicodeInput = False
        }

spec :: Spec
spec = do
    describe "config" $ do
      it "default config should pass config check" $
        doesNotRefuse (checkSuperfluousBracketsConfig defaultSuperfluousBracketsConfig :: LangM Maybe)
      it "validBoundsSuperfluousBracketsConfig should generate a valid config" $
        forAll validBoundsSuperfluousBracketsConfig $ \superfluousBracketsConfig ->
          doesNotRefuse (checkSuperfluousBracketsConfig superfluousBracketsConfig :: LangM Maybe)
    describe "description" $ do
      it "should not reject" $
       forAll validBoundsSuperfluousBracketsConfig $ \config ->
          forAll (generateSuperfluousBracketsInst config) $ \inst ->
            doesNotRefuse (description inst :: LangM Maybe)
    describe "sameAssociativeOperatorAdjacent" $ do
        it "should return false if there are no two \\/s or two /\\s as neighbors" $
            not $ sameAssociativeOperatorAdjacent (Binary Or (Leaf 'a') (Not (Binary Or (Leaf 'a') (Leaf 'c'))))
        it "should return true if two \\/s or two /\\s are Neighboring " $
            sameAssociativeOperatorAdjacent $
              Not $ Binary And (Binary Equi (Leaf 'a') (Leaf 'b')) (Binary And (Leaf 'a') (Leaf 'c'))
    describe "sameAssociativeOperatorAdjacent... functions" $
        it "is a consistent pair of functions" $
            forAll validBoundsSuperfluousBracketsConfig $
              \SuperfluousBracketsConfig {..} ->
                forAll
                  (genSynTree syntaxTreeConfig) $ \synTree ->
                    sameAssociativeOperatorAdjacent synTree ==>
                      notNull (sameAssociativeOperatorAdjacentSerial (numberAllBinaryNodes synTree) Nothing)
    describe "simplestDisplay and superfluousBracketsDisplay" $ do
        it "simplestDisplay should have less brackets than or equal to normal formula" $
            forAll validBoundsSuperfluousBracketsConfig $
              \SuperfluousBracketsConfig {..} ->
                forAll
                  (genSynTree syntaxTreeConfig) $ \synTree ->
                    length (sameAssociativeOperatorAdjacentSerial (numberAllBinaryNodes synTree) Nothing) *2
                      == length (display synTree) - length (simplestDisplay synTree)
        it
          ( "the number of brackets generated by simplestDisplay and display should be equal " ++
            "if 'sameAssociativeOperatorAdjacent' is not satisfied."
          ) $
            forAll (validBoundsSuperfluousBracketsConfig `suchThat` \cfg -> maxDepth (syntaxTreeConfig cfg) < 6) $
              \SuperfluousBracketsConfig {..} ->
                forAll
                (genSynTree syntaxTreeConfig) $
                  \synTree -> not (sameAssociativeOperatorAdjacent synTree) ==>
                    display synTree == simplestDisplay synTree
        it "after remove all bracket two strings should be same" $
            forAll validBoundsSuperfluousBracketsConfig $ \config ->
                forAll (generateSuperfluousBracketsInst config) $ \SuperfluousBracketsInst{..} ->
                  deleteBrackets stringWithSuperfluousBrackets == deleteBrackets simplestString
    describe "valid formula" $
        it "the formula Parser can accept when brackets is max number" $
            forAll validBoundsSuperfluousBracketsConfig $
              \SuperfluousBracketsConfig {..} ->
                forAll
                    (genSynTree syntaxTreeConfig
                      `suchThat` sameAssociativeOperatorAdjacent
                    ) $
                      \synTree -> forAll (superfluousBracketsDisplay synTree (treeNodes synTree + 1)) $
                        \stringWithSuperfluousBrackets ->
                          formulaParse stringWithSuperfluousBrackets == Right synTree
    describe "generateSuperfluousBracketsInst" $ do
        it "show and parse are inverse for parsePropForm (?)" $
            forAll validBoundsSuperfluousBracketsConfig $ \config ->
                forAll (generateSuperfluousBracketsInst config) $ \SuperfluousBracketsInst{..} ->
                  show (fromRight' (parse (parser @(PropFormula Char)) "" simplestString)) == simplestString
        it "the stringWithSuperfluousBrackets should have right number of SuperfluousBrackets" $
            forAll validBoundsSuperfluousBracketsConfig $ \config@SuperfluousBracketsConfig {..} ->
                forAll (generateSuperfluousBracketsInst config) $ \SuperfluousBracketsInst{..} ->
                  fromIntegral (length stringWithSuperfluousBrackets - length simplestString)
                    == superfluousBracketPairs * 2
        it "should pass grading" $
          forAll validBoundsSuperfluousBracketsConfig $ \config ->
              forAll (generateSuperfluousBracketsInst config) $ \inst ->
                doesNotRefuse (partialGrade' inst (fromRight' $ parse parser "Input" $ simplestString inst) :: LangM Maybe) &&
                 doesNotRefuse (completeGrade' inst (fromRight' $ parse parser "Input" $ simplestString inst) :: LangM Maybe)

